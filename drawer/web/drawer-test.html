<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>drawer</title>
</head>

<body style="display: none;">
	<h1>HDU-4283 区间DP</h1>

	<h2><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4283">HDU-4283</a></h2>

	<h2>题目描述</h2>

	<p>非诚勿扰, 男嘉宾上台选秀, 一人上台占用一时刻. 第$i$个人等待一时刻会产生$D[i]$屌丝值. 有一个黑房间先进后出, 导演可以用它来改变男嘉宾上台顺序. 求节目结束后最小总屌丝值和.</p>

	<h2>分析</h2>

	<ol>
		<li>房间本质是一个栈, 栈有自带的子结构性质: 最终的出栈队列, 一定是由入栈队列的一个或多个不定长<strong>顺序/逆序</strong>子队列组成的, 举几个例子:<br />


			<ul>
				<li>如{1,2,3,4,5}以{1,2,5,4,3}出栈, 则这些子队列是: {1,2},{5,4,3}.</li>
				<li>如{1,2,3,4,5}以{2,4,3,1,5}出栈, 则这些子队列是: {1},{2},{4,3},{5}.</li>
				<li>如{1,2,3,4,5}以{5,4,3,2,1}出栈, 则这些子队列是: {5,4,3,2,1}.</li>
				<li>因此, <strong>出入栈本身的复杂情况, 可以被简化为完全顺序/完全逆序序列的任意合法排列</strong>, 解题就转变成了一个枚举这些序列的过程.</li>
			</ul>
		</li>
		<li>进行孤立区间的划分. 划分选手编号区间$[i,j]$ $(1 \le i,j \le n)$:

			<ul>
				<li>$i=j$ 时, 代价不论如何都是$0$(就一个人).</li>
				<li>$i+1=j$ 时, 最小代价是 $D[i]$ 和 $D[i+1]$ 中较小值.</li>
				<li>$i+2=j$ 时情况变得复杂, 枚举栈的可能情况, 得到最小代价是以下五项的最小值:<br />
					\[
					\begin{align}
					2D[i] &amp;+D[i+1], &amp;&amp;(1) \\
					2D[i] &amp;+D[i+2], &amp;&amp;(2) \\
					2D[i+1] &amp;+D[i+2], &amp;&amp;(3) \\
					2D[i+2] &amp;+D[i] , &amp;&amp;(4) \\
					2D[i+2] &amp;+D[i+1], &amp;&amp;(5)
					\end{align}
					\]
					还有一项 $2D[i+1]+D[i]$ 不存在. 栈做不到.<br />
					不难看出, 各类情况都是由1:2这样的划分得出的:<br />


					<ul>
						<li>划分为 $A = [i]$ 和 $B = [i+1,i+2]$ 时, 有:<br />
							\[
							\begin{align}
							&amp;A先出B后出, 总代价为 \\
							&amp; &amp;A_{最小} + B_{最小} + B_{总体等待} \times len(A) &amp;&amp;=&gt; &amp;(3) \lor (5) \\
							&amp;B先出A后出, 总代价为 \\
							&amp; &amp;B_{最小} + A_{全逆序} + A_{总体等待} \times len(B) &amp;&amp;=&gt; &amp;(1) \lor (2)
							\end{align}
							\]<br />
						</li>
						<li>划分为 $A = [i,i+1]$ 和 $B = [i+2]$ 时, 有:<br />
							\[
							\begin{align}
							&amp;A先出B后出, 总代价为 \\
							&amp; &amp;A_{最小} + B_{最小} + B_{总体等待} \times len(A) &amp;&amp;=&gt; &amp;(4) \lor (5) \\
							&amp;B先出A后出, 总代价为 \\
							&amp; &amp;B_{最小} + A_{全逆序} + A_{总体等待} \times len(B) &amp;&amp;=&gt; &amp;(1)
							\end{align}
							\]</li>
						<li>为什么$B$先$A$后中的$A$要取全逆序呢? 是因为想让$B$先出, 就必须让$A$全部进栈. 在这一事实下, $A$的最小代价就无关了.</li>
					</ul>
				</li>
				<li>因此, <strong>一个区间的最优解一定唯一由其各个子区间的最优解和逆序边界解推导出</strong>.</li>
				<li>比较神奇的一件事. 这样的推导自动地避开了栈的不可能情况, 原因大概是推导本身就建立在栈的规则下, 没有越界.</li>
			</ul>
		</li>
	</ol>

	<p>最终结论: 在明确顺序/逆序排列组合性质的前提下, 我们分层讨论, 每层区间长度+1, 从1开始推到问题实际规模. 在每一层中再进行一次区间划分, 划分点从区间头到区间尾.
		这种推法保证可以枚举到所有合法的顺序/逆序排列(从下至上,
		每一层都枚举全, 则总体就是枚举全的, 而不需要在单层枚举全部情况, 这也是DP的核心思想之一).</p>

	<h3>注意: graph必须是根元素</h3>

	<h3>latex可以较为随意</h3>

	<p>
		<graph engine=2>
			graph G0 {
			0--1[color=blue];
			0--3[color=blue];
			1--2[color=blue];
			1--4[color=blue];
			2--5[color=blue];
			2--6[color=blue];
			4--5[color=blue];
			4--7[color=blue];
			3--4[color=blue];
			}
		</graph>
	</p>

	<h2>状态转移方程</h2>

	<p>根据上述分析进行转移方程的推导.</p>

	<p>设孤立区间$[i,j]$的<strong>每时刻总体等待代价</strong>为$wait[i][j]$
		<latex>
			\[
			wait[i][j] = \displaystyle \sum_{x=i}^j D[x] = wait[i][j-1]+D[j]
			\]
		</latex>
	</p>

	<p>设孤立区间$[i,j]$的<strong>全逆序代价</strong>为$rev[i][j]$
		<latex>
			\[
			rev[i][j] = \displaystyle \sum_{x=i}^{j} (j-x)D[x] = rev[i+1][j]+(j-i)D[i]
			\]
		</latex>
	</p>

	<p>设孤立区间$[i,j]$的<strong>最小代价</strong>为$dp[i][j]$
		<latex>
			\[
			\begin{align}
			初始值:dp[i][j] &= rev[i][j], \\
			递推值:dp[i][j] &= min\begin{cases}
			dp[i][j] \\
			dp[i][k] + dp[k+1][j] + (k-i+1)wait[k+1][j] \\
			dp[k+1][j] + rev[i][k] + (j-k)wait[i][k]
			\end{cases} , &&i \le k \lt j
			\end{align}
			\]
		</latex>
		这里的递推完全来自于上面的分析. 注意整个区间都逆序时的情况($k=j$), 也可能是最优解. 这里为了编程方便, 可以设置其为初始值.</p>

	<h2>心得</h2>

	<p><strong>关键在于对栈的子结构性质的洞察</strong>, 有了顺序/逆序的子结构, 区间DP就呼之欲出了.</p>

	<h2>代码</h2>

	<pre><code class="language-cpp">// -------------- GLOBAL ----------------
int D[150];
LL  dp[150][150], rev[150][150], wait[150][150];
// -------------- FUNC ----------------

// -------------- MAIN ----------------
int main() {
	int T;
	scanf(&quot;%d&quot;, &amp;T);
	for (int t = 1; t &lt;= t; ++t) {
		fill0(dp);
		ini(n);
		f1(i, n) {
			scanf(&quot;%d&quot;, d + i);
		}
		f1r(i, n) {
			for (int j = i; j &lt;= n; ++j) {
				wait[i][j] = wait[i][j - 1] + d[j];
			}
			for (int j = n; j &gt;= i; --j) {
				rev[i][j] = rev[i + 1][j] + (j - i) * D[i]; // 两个小dp
			}
		}
		F1(l, n - 1) { // 区间长度为l
			F1(i, n - l) {
				int j    = i + l;
				dp[i][j] = rev[i][j];
				for (int k = i; k &lt; j; ++k) { // 以k为划分点
					dp[i][j] = min(dp[i][j], min(dp[i][k] + dp[k + 1][j] + (k - i + 1) * wait[k + 1][j], dp[k + 1][j] + rev[i][k] + (j - k) * wait[i][k]));
				}
			}
		}
		printf(&quot;Case #%d: %lld\n&quot;, t, dp[1][n]);
	}
	return 0;
}
</code></pre>
</body>

</html>
<script src="./load.js" draw="not-need"></script>
<script draw="not-need">
	var AllLoad = false;
	var HLJSLoad = false;
	var VizHave = -1;
	var VizLoad = 0;
	var MathLoad = false;

	function LoadHLJS() {
		LoadScript("./highlight/highlight.pack.js", function () {
			hljs.initHighlighting();
			HLJSLoad = true;
		});
	}

	function LoadMathJax() {
		function loadText(textsDOM) {
			for (var i = 0; i < textsDOM.length; ++i) {
				if (textsDOM[i].innerHTML == null)
					continue;
				textsDOM[i].innerHTML = textsDOM[i].innerHTML.replace(/([^\\])\$(.+?)\$/g, '$1\\($2\\)');
				textsDOM[i].innerHTML = textsDOM[i].innerHTML.replace(/\\\$/, '\$');
			}
		}
		loadText(document.getElementsByTagName('p'));
		loadText(document.getElementsByTagName('li'));
		LoadScript("./mathjax/tex-mml-chtml.js", function () {
			// setTimeout(() => {
			MathLoad = true;
			// }, 1000);
		});
	}

	function LoadKatex() {
		function loadText(textsDOM) {
			for (var i = 0; i < textsDOM.length; ++i) {
				if (textsDOM[i].innerHTML == null)
					continue;
				textsDOM[i].innerHTML = textsDOM[i].innerHTML.replace(/\\\[/g, '\$\\begin{aligned}');
				textsDOM[i].innerHTML = textsDOM[i].innerHTML.replace(/\\\]/g, '\\end{aligned}\$');
				textsDOM[i].innerHTML = textsDOM[i].innerHTML.replace('\\begin{align}', '');
				textsDOM[i].innerHTML = textsDOM[i].innerHTML.replace('\\end{align}', '');
			}
		}
		loadText(document.getElementsByTagName('p'));
		loadText(document.getElementsByTagName('li'));
		LoadScript("./katex/katex.min.js", function () {
			LoadScript("./katex/contrib/auto-render.min.js", function () {
				renderMathInElement(document.body);
				MathLoad = true;
			});
		});
	}

	function LoadViz(callback) {
		function drawViz(graphDOM, engine, vizId) {
			function loadEnd() {
				VizLoad++;
				if (VizLoad == VizHave && typeof callback === "function") {
					callback();
				}
			}
			if (typeof engine === "undefined" || engine === null) engine = 3;
			var engines = ["circo", "dot", "fdp", "neato", "osage", "twopi"];
			LoadScript("./jquery-3.4.1.min.js", function () {
				LoadScript("./viz/viz.js", function () {
					LoadScript("./viz/full.render.js", function () {
						var viz = new Viz();
						viz.renderSVGElement(graphDOM.innerText, {
							engine: engines[engine],
							format: "svg",
						}).then(function (element) {
							graphDOM.innerHTML = "";
							graphDOM.appendChild(element);
							loadEnd();
						}).catch(function (error) {
							viz = new Viz();
							loadEnd();
							console.error(error);
						});
					});
				});
			});
		}
		var graphs = document.querySelectorAll('graph');
		VizHave = graphs.length;
		for (var i = 0; i < graphs.length; ++i) {
			if (!graphs[i].hasAttribute('drawn')) {
				drawViz(graphs[i], parseInt(graphs[i].getAttribute('engine')));
				graphs[i].setAttribute('drawn', '1');
			}
		}
		if (!VizHave && typeof callback === "function") {
			callback();
		}
	}

	function MakeMJStyle() {
		if (document.querySelectorAll("body #MJX-CHTML-styles").length !== 0)
			return;
		var mjstyleNode = document.getElementById("MJX-CHTML-styles");
		mjstyleNode.innerHTML += ".CtxtMenu_MenuFrame{display:none;}"; // 禁用菜单
		document.body.appendChild(mjstyleNode);
	}

	setInterval(() => {
		if (!AllLoad && HLJSLoad && VizHave == VizLoad && MathLoad) {
			// MakeMJStyle();
			document.body.removeAttribute("style");
			document.body.innerHTML += "<done></done>";
			AllLoad = true;
		}
	}, 100);

	LoadViz(() => {
		LoadHLJS();
		LoadMathJax();
	});
</script>